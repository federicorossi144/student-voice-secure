import { useContract, useContractRead, useContractWrite, useAccount } from 'wagmi';
import { useFHE } from '@fhevm/solidity';
import StudentVotingABI from '../contracts/StudentVoting.json';

const CONTRACT_ADDRESS = process.env.NEXT_PUBLIC_CONTRACT_ADDRESS || '0x0000000000000000000000000000000000000000';

export const useStudentVotingContract = () => {
  const { address } = useAccount();
  const { encrypt, decrypt } = useFHE();

  const contract = useContract({
    address: CONTRACT_ADDRESS as `0x${string}`,
    abi: StudentVotingABI.abi,
  });

  return {
    contract,
    address,
    encrypt,
    decrypt,
  };
};

export const useElections = () => {
  const { contract } = useStudentVotingContract();

  // This would need to be implemented based on your contract's structure
  // For now, we'll return mock data
  return {
    elections: [],
    isLoading: false,
    error: null,
  };
};

export const useCreateElection = () => {
  const { contract } = useStudentVotingContract();

  const { write: createElection, isLoading, error } = useContractWrite({
    address: CONTRACT_ADDRESS as `0x${string}`,
    abi: StudentVotingABI.abi,
    functionName: 'createElection',
  });

  return {
    createElection,
    isLoading,
    error,
  };
};

export const useAddCandidate = () => {
  const { contract } = useStudentVotingContract();

  const { write: addCandidate, isLoading, error } = useContractWrite({
    address: CONTRACT_ADDRESS as `0x${string}`,
    abi: StudentVotingABI.abi,
    functionName: 'addCandidate',
  });

  return {
    addCandidate,
    isLoading,
    error,
  };
};

export const useCastVote = () => {
  const { contract, encrypt } = useStudentVotingContract();

  const { write: castVote, isLoading, error } = useContractWrite({
    address: CONTRACT_ADDRESS as `0x${string}`,
    abi: StudentVotingABI.abi,
    functionName: 'castVote',
  });

  const castEncryptedVote = async (electionId: number, candidateId: number) => {
    try {
      // Encrypt the vote (1 for vote, 0 for no vote)
      const encryptedVote = await encrypt(1);
      
      // Cast the encrypted vote
      await castVote({
        args: [electionId, candidateId, encryptedVote, '0x'], // inputProof would be generated by FHE
      });
    } catch (err) {
      console.error('Error casting vote:', err);
      throw err;
    }
  };

  return {
    castVote: castEncryptedVote,
    isLoading,
    error,
  };
};

export const useRegisterStudent = () => {
  const { contract } = useStudentVotingContract();

  const { write: registerStudent, isLoading, error } = useContractWrite({
    address: CONTRACT_ADDRESS as `0x${string}`,
    abi: StudentVotingABI.abi,
    functionName: 'registerStudent',
  });

  return {
    registerStudent,
    isLoading,
    error,
  };
};

export const useStudentInfo = (studentAddress?: string) => {
  const { address } = useAccount();
  const targetAddress = studentAddress || address;

  const { data: studentInfo, isLoading, error } = useContractRead({
    address: CONTRACT_ADDRESS as `0x${string}`,
    abi: StudentVotingABI.abi,
    functionName: 'getStudentInfo',
    args: targetAddress ? [targetAddress] : undefined,
    enabled: !!targetAddress,
  });

  return {
    studentInfo,
    isLoading,
    error,
  };
};

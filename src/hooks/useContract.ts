import { useContractRead, useContractWrite, useAccount } from 'wagmi';
import StudentVotingABI from '../contracts/StudentVoting.json';

const CONTRACT_ADDRESS = process.env.NEXT_PUBLIC_CONTRACT_ADDRESS || '0x0000000000000000000000000000000000000000';

export const useStudentVotingContract = () => {
  const { address } = useAccount();

  return {
    address,
    contractAddress: CONTRACT_ADDRESS as `0x${string}`,
    abi: StudentVotingABI.abi,
  };
};

export const useElections = () => {
  // This would need to be implemented based on your contract's structure
  // For now, we'll return mock data
  return {
    elections: [],
    isLoading: false,
    error: null,
  };
};

export const useCreateElection = () => {
  const { contractAddress, abi } = useStudentVotingContract();

  const { write: createElection, isLoading, error } = useContractWrite({
    address: contractAddress,
    abi: abi,
    functionName: 'createElection',
  });

  return {
    createElection,
    isLoading,
    error,
  };
};

export const useAddCandidate = () => {
  const { contractAddress, abi } = useStudentVotingContract();

  const { write: addCandidate, isLoading, error } = useContractWrite({
    address: contractAddress,
    abi: abi,
    functionName: 'addCandidate',
  });

  return {
    addCandidate,
    isLoading,
    error,
  };
};

export const useCastVote = () => {
  const { contractAddress, abi } = useStudentVotingContract();

  const { write: castVote, isLoading, error } = useContractWrite({
    address: contractAddress,
    abi: abi,
    functionName: 'castVote',
  });

  const castEncryptedVote = async (electionId: number, candidateId: number) => {
    try {
      // For now, we'll use a placeholder for encrypted vote
      // In a real implementation, this would be handled by FHE
      const encryptedVote = '0x0000000000000000000000000000000000000000000000000000000000000001';
      
      // Cast the encrypted vote
      await castVote({
        args: [electionId, candidateId, encryptedVote, '0x'], // inputProof would be generated by FHE
      });
    } catch (err) {
      console.error('Error casting vote:', err);
      throw err;
    }
  };

  return {
    castVote: castEncryptedVote,
    isLoading,
    error,
  };
};

export const useRegisterStudent = () => {
  const { contractAddress, abi } = useStudentVotingContract();

  const { write: registerStudent, isLoading, error } = useContractWrite({
    address: contractAddress,
    abi: abi,
    functionName: 'registerStudent',
  });

  return {
    registerStudent,
    isLoading,
    error,
  };
};

export const useStudentInfo = (studentAddress?: string) => {
  const { address } = useAccount();
  const { contractAddress, abi } = useStudentVotingContract();
  const targetAddress = studentAddress || address;

  const { data: studentInfo, isLoading, error } = useContractRead({
    address: contractAddress,
    abi: abi,
    functionName: 'getStudentInfo',
    args: targetAddress ? [targetAddress] : undefined,
    enabled: !!targetAddress,
  });

  return {
    studentInfo,
    isLoading,
    error,
  };
};
